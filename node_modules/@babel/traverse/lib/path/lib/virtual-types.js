"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ForAwaitStatement = exports.NumericLiteralTypeAnnotation = exports.ExistentialTypeParam = exports.SpreadProperty = exports.RestProperty = exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = void 0;

<<<<<<< HEAD
var t = _interopRequireWildcard(require("@babel/types"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
=======
function t() {
  const data = _interopRequireWildcard(require("@babel/types"));

  t = function () {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; if (obj != null) { var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
>>>>>>> a0d14a2497264e6566ee5a25b965f3a4adaa178d

const ReferencedIdentifier = {
  types: ["Identifier", "JSXIdentifier"],

  checkPath(path, opts) {
    const {
      node,
      parent
    } = path;

<<<<<<< HEAD
    if (!t.isIdentifier(node, opts) && !t.isJSXMemberExpression(parent, opts)) {
      if (t.isJSXIdentifier(node, opts)) {
        if (t.react.isCompatTag(node.name)) return false;
=======
    if (!t().isIdentifier(node, opts) && !t().isJSXMemberExpression(parent, opts)) {
      if (t().isJSXIdentifier(node, opts)) {
        if (t().react.isCompatTag(node.name)) return false;
>>>>>>> a0d14a2497264e6566ee5a25b965f3a4adaa178d
      } else {
        return false;
      }
    }

<<<<<<< HEAD
    return t.isReferenced(node, parent, path.parentPath.parent);
=======
    return t().isReferenced(node, parent, path.parentPath.parent);
>>>>>>> a0d14a2497264e6566ee5a25b965f3a4adaa178d
  }

};
exports.ReferencedIdentifier = ReferencedIdentifier;
const ReferencedMemberExpression = {
  types: ["MemberExpression"],

  checkPath({
    node,
    parent
  }) {
<<<<<<< HEAD
    return t.isMemberExpression(node) && t.isReferenced(node, parent);
=======
    return t().isMemberExpression(node) && t().isReferenced(node, parent);
>>>>>>> a0d14a2497264e6566ee5a25b965f3a4adaa178d
  }

};
exports.ReferencedMemberExpression = ReferencedMemberExpression;
const BindingIdentifier = {
  types: ["Identifier"],

  checkPath(path) {
    const {
      node,
      parent
    } = path;
    const grandparent = path.parentPath.parent;
<<<<<<< HEAD
    return t.isIdentifier(node) && t.isBinding(node, parent, grandparent);
=======
    return t().isIdentifier(node) && t().isBinding(node, parent, grandparent);
>>>>>>> a0d14a2497264e6566ee5a25b965f3a4adaa178d
  }

};
exports.BindingIdentifier = BindingIdentifier;
const Statement = {
  types: ["Statement"],

  checkPath({
    node,
    parent
  }) {
<<<<<<< HEAD
    if (t.isStatement(node)) {
      if (t.isVariableDeclaration(node)) {
        if (t.isForXStatement(parent, {
          left: node
        })) return false;
        if (t.isForStatement(parent, {
=======
    if (t().isStatement(node)) {
      if (t().isVariableDeclaration(node)) {
        if (t().isForXStatement(parent, {
          left: node
        })) return false;
        if (t().isForStatement(parent, {
>>>>>>> a0d14a2497264e6566ee5a25b965f3a4adaa178d
          init: node
        })) return false;
      }

      return true;
    } else {
      return false;
    }
  }

};
exports.Statement = Statement;
const Expression = {
  types: ["Expression"],

  checkPath(path) {
    if (path.isIdentifier()) {
      return path.isReferencedIdentifier();
    } else {
<<<<<<< HEAD
      return t.isExpression(path.node);
=======
      return t().isExpression(path.node);
>>>>>>> a0d14a2497264e6566ee5a25b965f3a4adaa178d
    }
  }

};
exports.Expression = Expression;
const Scope = {
  types: ["Scopable"],

  checkPath(path) {
<<<<<<< HEAD
    return t.isScope(path.node, path.parent);
=======
    return t().isScope(path.node, path.parent);
>>>>>>> a0d14a2497264e6566ee5a25b965f3a4adaa178d
  }

};
exports.Scope = Scope;
const Referenced = {
  checkPath(path) {
<<<<<<< HEAD
    return t.isReferenced(path.node, path.parent);
=======
    return t().isReferenced(path.node, path.parent);
>>>>>>> a0d14a2497264e6566ee5a25b965f3a4adaa178d
  }

};
exports.Referenced = Referenced;
const BlockScoped = {
  checkPath(path) {
<<<<<<< HEAD
    return t.isBlockScoped(path.node);
=======
    return t().isBlockScoped(path.node);
>>>>>>> a0d14a2497264e6566ee5a25b965f3a4adaa178d
  }

};
exports.BlockScoped = BlockScoped;
const Var = {
  types: ["VariableDeclaration"],

  checkPath(path) {
<<<<<<< HEAD
    return t.isVar(path.node);
=======
    return t().isVar(path.node);
>>>>>>> a0d14a2497264e6566ee5a25b965f3a4adaa178d
  }

};
exports.Var = Var;
const User = {
  checkPath(path) {
    return path.node && !!path.node.loc;
  }

};
exports.User = User;
const Generated = {
  checkPath(path) {
    return !path.isUser();
  }

};
exports.Generated = Generated;
const Pure = {
  checkPath(path, opts) {
    return path.scope.isPure(path.node, opts);
  }

};
exports.Pure = Pure;
const Flow = {
  types: ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"],

  checkPath({
    node
  }) {
<<<<<<< HEAD
    if (t.isFlow(node)) {
      return true;
    } else if (t.isImportDeclaration(node)) {
      return node.importKind === "type" || node.importKind === "typeof";
    } else if (t.isExportDeclaration(node)) {
      return node.exportKind === "type";
    } else if (t.isImportSpecifier(node)) {
=======
    if (t().isFlow(node)) {
      return true;
    } else if (t().isImportDeclaration(node)) {
      return node.importKind === "type" || node.importKind === "typeof";
    } else if (t().isExportDeclaration(node)) {
      return node.exportKind === "type";
    } else if (t().isImportSpecifier(node)) {
>>>>>>> a0d14a2497264e6566ee5a25b965f3a4adaa178d
      return node.importKind === "type" || node.importKind === "typeof";
    } else {
      return false;
    }
  }

};
exports.Flow = Flow;
const RestProperty = {
  types: ["RestElement"],

  checkPath(path) {
    return path.parentPath && path.parentPath.isObjectPattern();
  }

};
exports.RestProperty = RestProperty;
const SpreadProperty = {
  types: ["RestElement"],

  checkPath(path) {
    return path.parentPath && path.parentPath.isObjectExpression();
  }

};
exports.SpreadProperty = SpreadProperty;
const ExistentialTypeParam = {
  types: ["ExistsTypeAnnotation"]
};
exports.ExistentialTypeParam = ExistentialTypeParam;
const NumericLiteralTypeAnnotation = {
  types: ["NumberLiteralTypeAnnotation"]
};
exports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;
const ForAwaitStatement = {
  types: ["ForOfStatement"],

  checkPath({
    node
  }) {
    return node.await === true;
  }

};
exports.ForAwaitStatement = ForAwaitStatement;